// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

import { TransferrableOwnership } from "../Helpers/TransferrableOwnership.sol";
import { MerkleProof } from "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";
import { NativeAssetTransferFailed } from "../Errors/GenericErrors.sol";
import { LibAsset, IERC20 } from "../Libraries/LibAsset.sol";

/// @title GasRebateDistributor
/// @author LI.FI (https://li.fi)
/// @notice Contract to distribute gas rebates from a LI.FI marketing campaign
/// @custom:version 1.0.0
contract GasRebateDistributor is TransferrableOwnership {
    /// Storage ///

    /// stores the root of the merkle tree that contains info about which account can claim which amount in which token
    bytes32 public merkleRoot;
    /// (account => tokenAddress => latestClaimedMerkleRootVersion) mapping from account to token address to the latest merkle root version that was claimed by this address
    mapping(address => mapping(address => uint8)) private _hasClaimed;
    /// stores the current version of the merkle root
    uint8 private _currentMerkleRootVersion;
    /// stores the timestamp until the claims of the current merkle root can be claimed
    uint256 public claimableUntil;

    /// Errors ///

    error AlreadyClaimed();
    error InvalidProof();
    error ClaimDeadlineExpired();

    /// Events ///

    event Claimed(
        address indexed account,
        address indexed tokenAddress,
        uint256 amount
    );

    /// Constructor
    constructor(
        address owner_,
        bytes32 merkleRoot_
    ) TransferrableOwnership(owner_) {
        merkleRoot = merkleRoot_;
    }

    /// EXTERNAL FUNCTIONS ///

    /// @notice Allows the caller of this function to claim the specified amount if presented with a valid merkle proof
    /// @param amount the amount that should be claimed
    /// @param tokenAddress the address of the token to be claimed (address(0) for native)
    /// @param merkleProof the merkle proof required to verify the claim (this proof is generated by LI.FI backend)
    function claim(
        address tokenAddress,
        uint256 amount,
        bytes32[] calldata merkleProof
    ) public virtual {
        // check if account claimed already for the current merkle root version
        if (_hasClaimed[tokenAddress][msg.sender] == _currentMerkleRootVersion)
            revert AlreadyClaimed();

        // check if claim deadline is expired
        if (block.timestamp > claimableUntil) revert ClaimDeadlineExpired();

        // Verify the merkle proof
        bytes32 node = keccak256(
            abi.encodePacked(msg.sender, tokenAddress, amount)
        );
        if (!MerkleProof.verify(merkleProof, merkleRoot, node))
            revert InvalidProof();

        // Mark the account as claimed for the current merkle root version
        _hasClaimed[tokenAddress][msg.sender] = _currentMerkleRootVersion;

        // send specified and validated amount of tokens to caller
        LibAsset.transferAsset(tokenAddress, payable(msg.sender), amount);

        emit Claimed(msg.sender, tokenAddress, amount);
    }

    /// ADMIN FUNCTIONS ///

    /// @notice Sends all unclaimed token balance(s) to the specified address
    /// @param to the address unclaimed funds should be sent to
    function withdrawUnclaimed(
        address[] calldata tokenAddresses,
        address to
    ) public onlyOwner {
        for (uint i; i < tokenAddresses.length; ) {
            uint256 balance = LibAsset.isNativeAsset(tokenAddresses[i])
                ? address(this).balance
                : IERC20(tokenAddresses[i]).balanceOf(address(this));
            // send specified and validated amount of tokens to caller
            LibAsset.transferAsset(tokenAddresses[i], payable(to), balance);
            unchecked {
                ++i;
            }
        }
    }

    /// @notice Updates the merkle root and its version to allow wallets that have previously claimed to claim again, if permitted
    /// @param newMerkleRoot the new merkle root
    /// @param deadline timestamp until claims for this merkle root are claimable
    function updateMerkleRoot(
        bytes32 newMerkleRoot,
        uint256 deadline
    ) public onlyOwner {
        // update the merkle root
        merkleRoot = newMerkleRoot;

        // update the claimable-until deadline
        claimableUntil = deadline;

        // increase the merkle root version
        _currentMerkleRootVersion++;
    }
}
