// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

import { TransferrableOwnership } from "../Helpers/TransferrableOwnership.sol";
import { MerkleProof } from "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";
import { NativeAssetTransferFailed } from "../Errors/GenericErrors.sol";

/// @title GasRebateDistributor
/// @author LI.FI (https://li.fi)
/// @notice Contract to distribute gas rebates from a LI.FI marketing campaign
/// @custom:version 1.0.0
/// Implementation derived from https://github.com/Uniswap/merkle-distributor/blob/master/contracts/MerkleDistributor.sol
contract GasRebateDistributor is TransferrableOwnership {
    /// Storage ///
    bytes32 public merkleRoot;
    /// mapping from address to the latest merkle root version that was claimed by this address
    mapping(address => uint8) private _hasClaimed;
    /// stores the current version of the merkle root
    uint8 private _currentMerkleRootVersion;
    /// stores the timestamp until the claims of the current merkle root can be claimed
    uint256 public claimableUntil;

    /// Errors ///
    error AlreadyClaimed();
    error InvalidProof();
    error ClaimDeadlineExpired();

    /// Events ///
    event Claimed(address account, uint256 amount);

    /// Constructor
    constructor(
        address owner_,
        bytes32 merkleRoot_
    ) TransferrableOwnership(owner_) {
        merkleRoot = merkleRoot_;
    }

    /// EXTERNAL FUNCTIONS ///

    /// @notice Allows the caller of this function to claim the specified amount if presented with a valid merkle proof
    /// @param amount the amount that should be claimed
    /// @param merkleProof the merkle proof required to verify the claim (this proof is generated by LI.FI backend)
    function claim(
        uint256 amount,
        bytes32[] calldata merkleProof
    ) public virtual {
        // check if account claimed already
        if (_isClaimed(msg.sender)) revert AlreadyClaimed();
        // check if claim deadline is expired
        if (block.timestamp > claimableUntil) revert ClaimDeadlineExpired();
        // Verify the merkle proof
        bytes32 node = keccak256(abi.encodePacked(msg.sender, amount));
        if (!MerkleProof.verify(merkleProof, merkleRoot, node))
            revert InvalidProof();
        // Mark the account as claimed for the current merkle root version
        _hasClaimed[msg.sender] = _currentMerkleRootVersion;
        // send specified and validated amount of native tokens to caller
        _sendNative(msg.sender, amount);
        emit Claimed(msg.sender, amount);
    }

    /// ADMIN FUNCTIONS ///

    /// @notice Sends all unclaimed native balance to the specified address
    /// @param to the address unclaimed funds should be sent to
    function withdrawUnclaimed(address to) public onlyOwner {
        uint256 balance = address(this).balance;
        // send all native balance to specified receiver address
        _sendNative(to, balance);
        emit Claimed(msg.sender, balance);
    }

    /// @notice Updates the merkle root and its version to allow wallets that have previously claimed to claim again, if permitted
    /// @param newMerkleRoot the new merkle root
    /// @param deadline timestamp until claims for this merkle root are claimable
    function updateMerkleRoot(
        bytes32 newMerkleRoot,
        uint256 deadline
    ) public onlyOwner {
        // update the merkle root
        merkleRoot = newMerkleRoot;
        // update the claimable-until deadline
        claimableUntil = deadline;
        // increase the merkle root version
        _currentMerkleRootVersion++;
    }

    /// PRIVATE HELPER FUNCTIONS ///

    function _sendNative(address account, uint256 amount) private {
        (bool success, ) = account.call{ value: amount }("");
        if (!success) revert NativeAssetTransferFailed();
    }

    function _isClaimed(address account) private view returns (bool) {
        if (_hasClaimed[account] == _currentMerkleRootVersion) return true;
        else return false;
    }
}
